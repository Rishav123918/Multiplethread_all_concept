| Method                 | Syntax Example                                                 | What It Does                                                                                       | When to Use                                                               |
| ---------------------- | -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **`thenApply`**        | `future.thenApply(result -> transform(result))`                | Takes the result, returns a **new value** synchronously.                                           | When transformation is quick and doesn’t need a separate thread.          |
| **`thenApplyAsync`**   | `future.thenApplyAsync(result -> transform(result))`           | Same as `thenApply`, but runs the function in a **different thread** (default or custom executor). | For CPU-heavy transformations you don’t want blocking current thread.     |
| **`thenAccept`**       | `future.thenAccept(result -> System.out.println(result))`      | Consumes the result, **no return value**.                                                          | When you just want to perform an action (e.g., logging) after completion. |
| **`thenAcceptAsync`**  | `future.thenAcceptAsync(result -> log(result))`                | Same as `thenAccept`, but runs consumer in **another thread**.                                     | For actions that shouldn’t block current thread.                          |
| **`thenCombine`**      | `future1.thenCombine(future2, (r1, r2) -> merge(r1, r2))`      | Combines **two futures’ results** once both complete, synchronously.                               | When you need results from two async tasks to produce a new value.        |
| **`thenCombineAsync`** | `future1.thenCombineAsync(future2, (r1, r2) -> merge(r1, r2))` | Same as `thenCombine`, but merging runs in **another thread**.                                     | When combining logic is heavy.                                            |
| **`thenCompose`**      | `future.thenCompose(result -> nextAsyncTask(result))`          | Flattens nested futures (future of future → single future).                                        | When next step **returns another CompletableFuture**.                     |
| **`thenComposeAsync`** | `future.thenComposeAsync(result -> nextAsyncTask(result))`     | Same as `thenCompose`, but runs in **another thread**.                                             | For chaining async calls without blocking.                                |
